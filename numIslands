func numIslands(grid [][]byte) int {
    stack := Stack{nodes: make([][2]int, 0)}
    islands := 0
    for i:=0; i < len(grid); i++{
        for j:=0 ; j < len(grid[0]); j++{
            if grid[i][j]=='1'{
                islands+=1
                stack.Add([2]int{i,j})
                grid[i][j]= '0'
                for !stack.IsEmpty(){
                    moves(grid, &stack)
                }
            }
        }
    }
    return islands
}



func moves(grid [][]byte, s *Stack){
    
    n := s.Remove()
    i:=n[0]
    j:=n[1]

    if i+1 < len(grid) && grid[i+1][j] == '1'{
        n := [2]int{i+1,j}
        s.Add(n)
        grid[i+1][j]= '0'
        fmt.Println("bingo")
    }
    if  i-1 >= 0 && grid[i-1][j] == '1'{
        n := [2]int{i-1,j}
        s.Add(n)
        grid[i-1][j]= '0'

    }
    if j+1< len(grid[i]) && grid[i][j+1] == '1'{
        n := [2]int{i,j+1}
        s.Add(n)
        grid[i][j+1]= '0'

    }
    if j-1 >=0 && grid[i][j-1] == '1'{
        n := [2]int{i,j-1}
        s.Add(n)
        grid[i][j-1]= '0'
    }
}

func printGrid(grid [][]byte) {
    for _, row := range grid {
        for _, val := range row {
            fmt.Printf("%c ", val)
        }
        fmt.Println()
    }
    fmt.Println()
    fmt.Println()

}

func (s *Stack) IsEmpty() bool{
    if len(s.nodes) > 0 {
        return false
    }
    return true
}


func (s *Stack) Add(node [2]int){
    s.nodes = append(s.nodes, node)
}

func (s *Stack) Remove() [2]int {

    node := s.nodes[len(s.nodes)-1]
    s.nodes = s.nodes[:len(s.nodes)-1]
    
    return node
}

type Stack struct{
    nodes [][2]int
}

